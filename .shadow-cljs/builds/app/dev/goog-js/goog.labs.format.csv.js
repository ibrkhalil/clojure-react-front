["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/labs/format/csv.js"],"~:js","goog.provide(\"goog.labs.format.csv\");\ngoog.provide(\"goog.labs.format.csv.ParseError\");\ngoog.provide(\"goog.labs.format.csv.Token\");\ngoog.require(\"goog.array\");\ngoog.require(\"goog.asserts\");\ngoog.require(\"goog.debug.Error\");\ngoog.require(\"goog.object\");\ngoog.require(\"goog.string\");\ngoog.require(\"goog.string.newlines\");\ngoog.labs.format.csv.ENABLE_VERBOSE_DEBUGGING = goog.DEBUG;\ngoog.labs.format.csv.ParseError = function(text, index, opt_message) {\n  var message;\n  this.position = null;\n  if (goog.labs.format.csv.ENABLE_VERBOSE_DEBUGGING) {\n    message = opt_message || \"\";\n    var info = goog.labs.format.csv.ParseError.findLineInfo_(text, index);\n    if (info) {\n      var lineNumber = info.lineIndex + 1;\n      var columnNumber = index - info.line.startLineIndex + 1;\n      this.position = {line:lineNumber, column:columnNumber};\n      message += goog.string.subs(\" at line %s column %s\", lineNumber, columnNumber);\n      message += \"\\n\" + goog.labs.format.csv.ParseError.getLineDebugString_(info.line.getContent(), columnNumber);\n    }\n  }\n  goog.labs.format.csv.ParseError.base(this, \"constructor\", message);\n};\ngoog.inherits(goog.labs.format.csv.ParseError, goog.debug.Error);\ngoog.labs.format.csv.ParseError.prototype.name = \"ParseError\";\ngoog.labs.format.csv.ParseError.findLineInfo_ = function(str, index) {\n  var lines = goog.string.newlines.getLines(str);\n  var lineIndex = goog.array.findIndex(lines, function(line) {\n    return line.startLineIndex <= index && line.endLineIndex > index;\n  });\n  if (typeof lineIndex === \"number\") {\n    var line = lines[lineIndex];\n    return {line:line, lineIndex:lineIndex};\n  }\n  return null;\n};\ngoog.labs.format.csv.ParseError.getLineDebugString_ = function(str, column) {\n  var returnString = str + \"\\n\";\n  returnString += goog.string.repeat(\" \", column - 1) + \"^\";\n  return returnString;\n};\ngoog.labs.format.csv.Token;\ngoog.labs.format.csv.parse = function(text, opt_ignoreErrors, opt_delimiter) {\n  var index = 0;\n  var delimiter = opt_delimiter || \",\";\n  goog.asserts.assert(delimiter.length == 1, \"Delimiter must be a single character.\");\n  goog.asserts.assert(delimiter != \"\\r\" && opt_delimiter != \"\\n\", \"Cannot use newline or carriage return has delimiter.\");\n  var EOF = goog.labs.format.csv.Sentinels_.EOF;\n  var EOR = goog.labs.format.csv.Sentinels_.EOR;\n  var NEWLINE = goog.labs.format.csv.Sentinels_.NEWLINE;\n  var EMPTY = goog.labs.format.csv.Sentinels_.EMPTY;\n  var pushBackToken = null;\n  var sawComma = false;\n  function pushBack(t) {\n    goog.labs.format.csv.assertToken_(t);\n    goog.asserts.assert(pushBackToken === null);\n    pushBackToken = t;\n  }\n  function nextToken() {\n    if (pushBackToken != null) {\n      var c = pushBackToken;\n      pushBackToken = null;\n      return c;\n    }\n    if (index >= text.length) {\n      return EOF;\n    }\n    var chr = text.charAt(index++);\n    goog.labs.format.csv.assertToken_(chr);\n    var isNewline = false;\n    if (chr == \"\\n\") {\n      isNewline = true;\n    } else {\n      if (chr == \"\\r\") {\n        if (index < text.length && text.charAt(index) == \"\\n\") {\n          index++;\n        }\n        isNewline = true;\n      }\n    }\n    if (isNewline) {\n      return NEWLINE;\n    }\n    return chr;\n  }\n  function readQuotedField() {\n    var start = index;\n    var end = null;\n    for (var token = nextToken(); token != EOF; token = nextToken()) {\n      if (token == '\"') {\n        end = index - 1;\n        token = nextToken();\n        if (token == '\"') {\n          end = null;\n          continue;\n        }\n        if (token == delimiter || token == EOF || token == NEWLINE) {\n          if (token == NEWLINE) {\n            pushBack(token);\n          }\n          if (token == delimiter) {\n            sawComma = true;\n          }\n          break;\n        }\n        if (!opt_ignoreErrors) {\n          throw new goog.labs.format.csv.ParseError(text, index - 1, 'Unexpected character \"' + token + '\" after quote mark');\n        } else {\n          var prefix = '\"' + text.substring(start, index);\n          var suffix = readField();\n          if (suffix == EOR) {\n            pushBack(NEWLINE);\n            return prefix;\n          } else {\n            return prefix + suffix;\n          }\n        }\n      }\n    }\n    if (end === null) {\n      if (!opt_ignoreErrors) {\n        throw new goog.labs.format.csv.ParseError(text, text.length - 1, \"Unexpected end of text after open quote\");\n      } else {\n        end = text.length;\n      }\n    }\n    return text.substring(start, end).replace(/\"\"/g, '\"');\n  }\n  function readField() {\n    var start = index;\n    var didSeeComma = sawComma;\n    sawComma = false;\n    var token = nextToken();\n    if (token == EMPTY) {\n      return EOR;\n    }\n    if (token == EOF || token == NEWLINE) {\n      if (didSeeComma) {\n        pushBack(EMPTY);\n        return \"\";\n      }\n      return EOR;\n    }\n    if (token == '\"') {\n      return readQuotedField();\n    }\n    while (true) {\n      if (token == EOF || token == NEWLINE) {\n        pushBack(token);\n        break;\n      }\n      if (token == delimiter) {\n        sawComma = true;\n        break;\n      }\n      if (token == '\"' && !opt_ignoreErrors) {\n        throw new goog.labs.format.csv.ParseError(text, index - 1, \"Unexpected quote mark\");\n      }\n      token = nextToken();\n    }\n    var returnString = token == EOF ? text.substring(start) : text.substring(start, index - 1);\n    return returnString.replace(/[\\r\\n]+/g, \"\");\n  }\n  function readRecord() {\n    if (index >= text.length) {\n      return EOF;\n    }\n    var record = [];\n    for (var field = readField(); field != EOR; field = readField()) {\n      record.push(field);\n    }\n    return record;\n  }\n  var records = [];\n  for (var record = readRecord(); record != EOF; record = readRecord()) {\n    records.push(record);\n  }\n  return records;\n};\ngoog.labs.format.csv.Sentinels_ = {EMPTY:{}, EOF:{}, EOR:{}, NEWLINE:{}};\ngoog.labs.format.csv.isCharacterString_ = function(str) {\n  return typeof str === \"string\" && str.length == 1;\n};\ngoog.labs.format.csv.assertToken_ = function(o) {\n  if (typeof o === \"string\") {\n    goog.asserts.assertString(o);\n    goog.asserts.assert(goog.labs.format.csv.isCharacterString_(o), \"Should be a string of length 1 or a sentinel.\");\n  } else {\n    goog.asserts.assert(goog.object.containsValue(goog.labs.format.csv.Sentinels_, o), \"Should be a string of length 1 or a sentinel.\");\n  }\n};\n","~:source","/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Provides a parser that turns a string of well-formed CSV data\n * into an array of objects or an array of arrays. All values are returned as\n * strings; the user has to convert data into numbers or Dates as required.\n * Empty fields (adjacent commas) are returned as empty strings.\n *\n * This parser uses http://tools.ietf.org/html/rfc4180 as the definition of CSV.\n */\n\n// TODO(user): We're trying to migrate all ES5 subclasses of Closure\n// Library to ES6. In ES6 this cannot be referenced before super is called. This\n// file has at least one this before a super call (in ES5) and cannot be\n// automatically upgraded to ES6 as a result. Please fix this if you have a\n// chance. Note: This can sometimes be caused by not calling the super\n// constructor at all. You can run the conversion tool yourself to see what it\n// does on this file: blaze run //javascript/refactoring/es6_classes:convert.\n\ngoog.provide('goog.labs.format.csv');\ngoog.provide('goog.labs.format.csv.ParseError');\ngoog.provide('goog.labs.format.csv.Token');\n\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.debug.Error');\ngoog.require('goog.object');\ngoog.require('goog.string');\ngoog.require('goog.string.newlines');\n\n\n/**\n * @define {boolean} Enable verbose debugging. This is a flag so it can be\n * enabled in production if necessary post-compilation.  Otherwise, debug\n * information will be stripped to minimize final code size.\n */\ngoog.labs.format.csv.ENABLE_VERBOSE_DEBUGGING = goog.DEBUG;\n\n\n\n/**\n * Error thrown when parsing fails.\n *\n * @param {string} text The CSV source text being parsed.\n * @param {number} index The index, in the string, of the position of the\n *      error.\n * @param {string=} opt_message A description of the violated parse expectation.\n * @constructor\n * @extends {goog.debug.Error}\n * @final\n */\ngoog.labs.format.csv.ParseError = function(text, index, opt_message) {\n  'use strict';\n  var message;\n\n  /**\n   * @type {?{line: number, column: number}} The line and column of the parse\n   *     error.\n   */\n  this.position = null;\n\n  if (goog.labs.format.csv.ENABLE_VERBOSE_DEBUGGING) {\n    message = opt_message || '';\n\n    var info = goog.labs.format.csv.ParseError.findLineInfo_(text, index);\n    if (info) {\n      var lineNumber = info.lineIndex + 1;\n      var columnNumber = index - info.line.startLineIndex + 1;\n\n      this.position = {line: lineNumber, column: columnNumber};\n\n      message +=\n          goog.string.subs(' at line %s column %s', lineNumber, columnNumber);\n      message += '\\n' +\n          goog.labs.format.csv.ParseError.getLineDebugString_(\n              info.line.getContent(), columnNumber);\n    }\n  }\n\n  goog.labs.format.csv.ParseError.base(this, 'constructor', message);\n};\ngoog.inherits(goog.labs.format.csv.ParseError, goog.debug.Error);\n\n\n/** @inheritDoc */\ngoog.labs.format.csv.ParseError.prototype.name = 'ParseError';\n\n\n/**\n * Calculate the line and column for an index in a string.\n * TODO(nnaze): Consider moving to goog.string.newlines.\n * @param {string} str A string.\n * @param {number} index An index into the string.\n * @return {?{line: !goog.string.newlines.Line, lineIndex: number}} The line\n *     and index of the line.\n * @private\n */\ngoog.labs.format.csv.ParseError.findLineInfo_ = function(str, index) {\n  'use strict';\n  var lines = goog.string.newlines.getLines(str);\n  var lineIndex = goog.array.findIndex(lines, function(line) {\n    'use strict';\n    return line.startLineIndex <= index && line.endLineIndex > index;\n  });\n\n  if (typeof (lineIndex) === 'number') {\n    var line = lines[lineIndex];\n    return {line: line, lineIndex: lineIndex};\n  }\n\n  return null;\n};\n\n\n/**\n * Get a debug string of a line and a pointing caret beneath it.\n * @param {string} str The string.\n * @param {number} column The column to point at (1-indexed).\n * @return {string} The debug line.\n * @private\n */\ngoog.labs.format.csv.ParseError.getLineDebugString_ = function(str, column) {\n  'use strict';\n  var returnString = str + '\\n';\n  returnString += goog.string.repeat(' ', column - 1) + '^';\n  return returnString;\n};\n\n\n/**\n * A token -- a single-character string or a sentinel.\n * @typedef {string|!goog.labs.format.csv.Sentinels_}\n */\ngoog.labs.format.csv.Token;\n\n\n/**\n * Parses a CSV string to create a two-dimensional array.\n *\n * This function does not process header lines, etc -- such transformations can\n * be made on the resulting array.\n *\n * @param {string} text The entire CSV text to be parsed.\n * @param {boolean=} opt_ignoreErrors Whether to ignore parsing errors and\n *      instead try to recover and keep going.\n * @param {string=} opt_delimiter The delimiter to use. Defaults to ','\n * @return {!Array<!Array<string>>} The parsed CSV.\n */\ngoog.labs.format.csv.parse = function(text, opt_ignoreErrors, opt_delimiter) {\n  'use strict';\n  var index = 0;  // current char offset being considered\n\n  var delimiter = opt_delimiter || ',';\n  goog.asserts.assert(\n      delimiter.length == 1, 'Delimiter must be a single character.');\n  goog.asserts.assert(\n      delimiter != '\\r' && opt_delimiter != '\\n',\n      'Cannot use newline or carriage return has delimiter.');\n\n  var EOF = goog.labs.format.csv.Sentinels_.EOF;\n  var EOR = goog.labs.format.csv.Sentinels_.EOR;\n  var NEWLINE = goog.labs.format.csv.Sentinels_.NEWLINE;  // \\r?\\n\n  var EMPTY = goog.labs.format.csv.Sentinels_.EMPTY;\n\n  var pushBackToken = null;  // A single-token pushback.\n  var sawComma = false;      // Special case for terminal comma.\n\n  /**\n   * Push a single token into the push-back variable.\n   * @param {goog.labs.format.csv.Token} t Single token.\n   */\n  function pushBack(t) {\n    goog.labs.format.csv.assertToken_(t);\n    goog.asserts.assert(pushBackToken === null);\n    pushBackToken = t;\n  }\n\n  /**\n   * @return {goog.labs.format.csv.Token} The next token in the stream.\n   */\n  function nextToken() {\n    // Give the push back token if present.\n    if (pushBackToken != null) {\n      var c = pushBackToken;\n      pushBackToken = null;\n      return c;\n    }\n\n    // We're done. EOF.\n    if (index >= text.length) {\n      return EOF;\n    }\n\n    // Give the next charater.\n    var chr = text.charAt(index++);\n    goog.labs.format.csv.assertToken_(chr);\n\n    // Check if this is a newline.  If so, give the new line sentinel.\n    var isNewline = false;\n    if (chr == '\\n') {\n      isNewline = true;\n    } else if (chr == '\\r') {\n      // This is a '\\r\\n' newline. Treat as single token, go\n      // forward two indicies.\n      if (index < text.length && text.charAt(index) == '\\n') {\n        index++;\n      }\n\n      isNewline = true;\n    }\n\n    if (isNewline) {\n      return NEWLINE;\n    }\n\n    return chr;\n  }\n\n  /**\n   * Read a quoted field from input.\n   * @return {string} The field, as a string.\n   */\n  function readQuotedField() {\n    // We've already consumed the first quote by the time we get here.\n    var start = index;\n    var end = null;\n\n    for (var token = nextToken(); token != EOF; token = nextToken()) {\n      if (token == '\"') {\n        end = index - 1;\n        token = nextToken();\n\n        // Two double quotes in a row.  Keep scanning.\n        if (token == '\"') {\n          end = null;\n          continue;\n        }\n\n        // End of field.  Break out.\n        if (token == delimiter || token == EOF || token == NEWLINE) {\n          if (token == NEWLINE) {\n            pushBack(token);\n          }\n          if (token == delimiter) {\n            sawComma = true;\n          }\n          break;\n        }\n\n        if (!opt_ignoreErrors) {\n          // Ignoring errors here means keep going in current field after\n          // closing quote. E.g. \"ab\"c,d splits into abc,d\n          throw new goog.labs.format.csv.ParseError(\n              text, index - 1,\n              'Unexpected character \"' + token + '\" after quote mark');\n        } else {\n          // Fall back to reading the rest of this field as unquoted.\n          // Note: the rest is guaranteed not start with \", as that case is\n          // eliminated above.\n          var prefix = '\"' + text.substring(start, index);\n          var suffix = readField();\n          if (suffix == EOR) {\n            pushBack(NEWLINE);\n            return prefix;\n          } else {\n            return prefix + suffix;\n          }\n        }\n      }\n    }\n\n    if (end === null) {\n      if (!opt_ignoreErrors) {\n        throw new goog.labs.format.csv.ParseError(\n            text, text.length - 1, 'Unexpected end of text after open quote');\n      } else {\n        end = text.length;\n      }\n    }\n\n    // Take substring, combine double quotes.\n    return text.substring(start, end).replace(/\"\"/g, '\"');\n  }\n\n  /**\n   * Read a field from input.\n   * @return {string|!goog.labs.format.csv.Sentinels_} The field, as a string,\n   *     or a sentinel (if applicable).\n   */\n  function readField() {\n    var start = index;\n    var didSeeComma = sawComma;\n    sawComma = false;\n    var token = nextToken();\n    if (token == EMPTY) {\n      return EOR;\n    }\n    if (token == EOF || token == NEWLINE) {\n      if (didSeeComma) {\n        pushBack(EMPTY);\n        return '';\n      }\n      return EOR;\n    }\n\n    // This is the beginning of a quoted field.\n    if (token == '\"') {\n      return readQuotedField();\n    }\n\n    while (true) {\n      // This is the end of line or file.\n      if (token == EOF || token == NEWLINE) {\n        pushBack(token);\n        break;\n      }\n\n      // This is the end of record.\n      if (token == delimiter) {\n        sawComma = true;\n        break;\n      }\n\n      if (token == '\"' && !opt_ignoreErrors) {\n        throw new goog.labs.format.csv.ParseError(\n            text, index - 1, 'Unexpected quote mark');\n      }\n\n      token = nextToken();\n    }\n\n\n    var returnString = (token == EOF) ?\n        text.substring(start) :  // Return to end of file.\n        text.substring(start, index - 1);\n\n    return returnString.replace(/[\\r\\n]+/g, '');  // Squash any CRLFs.\n  }\n\n  /**\n   * Read the next record.\n   * @return {!Array<string>|!goog.labs.format.csv.Sentinels_} A single record\n   *     with multiple fields.\n   */\n  function readRecord() {\n    if (index >= text.length) {\n      return EOF;\n    }\n    var record = [];\n    for (var field = readField(); field != EOR; field = readField()) {\n      record.push(field);\n    }\n    return record;\n  }\n\n  // Read all records and return.\n  var records = [];\n  for (var record = readRecord(); record != EOF; record = readRecord()) {\n    records.push(record);\n  }\n  return records;\n};\n\n\n/**\n * Sentinel tracking objects.\n * @enum {!Object}\n * @private\n */\ngoog.labs.format.csv.Sentinels_ = {\n  /** Empty field */\n  EMPTY: {},\n\n  /** End of file */\n  EOF: {},\n\n  /** End of record */\n  EOR: {},\n\n  /** Newline. \\r?\\n */\n  NEWLINE: {}\n};\n\n\n/**\n * @param {string} str A string.\n * @return {boolean} Whether the string is a single character.\n * @private\n */\ngoog.labs.format.csv.isCharacterString_ = function(str) {\n  'use strict';\n  return typeof str === 'string' && str.length == 1;\n};\n\n\n/**\n * Assert the parameter is a token.\n * @param {*} o What should be a token.\n * @throws {goog.asserts.AssertionError} If {@ code} is not a token.\n * @private\n */\ngoog.labs.format.csv.assertToken_ = function(o) {\n  'use strict';\n  if (typeof o === 'string') {\n    goog.asserts.assertString(o);\n    goog.asserts.assert(\n        goog.labs.format.csv.isCharacterString_(o),\n        'Should be a string of length 1 or a sentinel.');\n  } else {\n    goog.asserts.assert(\n        goog.object.containsValue(goog.labs.format.csv.Sentinels_, o),\n        'Should be a string of length 1 or a sentinel.');\n  }\n};\n","~:compiled-at",1633636256378,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.labs.format.csv.js\",\n\"lineCount\":195,\n\"mappings\":\"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\",\n\"sources\":[\"goog/labs/format/csv.js\"],\n\"sourcesContent\":[\"/**\\n * @license\\n * Copyright The Closure Library Authors.\\n * SPDX-License-Identifier: Apache-2.0\\n */\\n\\n/**\\n * @fileoverview Provides a parser that turns a string of well-formed CSV data\\n * into an array of objects or an array of arrays. All values are returned as\\n * strings; the user has to convert data into numbers or Dates as required.\\n * Empty fields (adjacent commas) are returned as empty strings.\\n *\\n * This parser uses http://tools.ietf.org/html/rfc4180 as the definition of CSV.\\n */\\n\\n// TODO(user): We're trying to migrate all ES5 subclasses of Closure\\n// Library to ES6. In ES6 this cannot be referenced before super is called. This\\n// file has at least one this before a super call (in ES5) and cannot be\\n// automatically upgraded to ES6 as a result. Please fix this if you have a\\n// chance. Note: This can sometimes be caused by not calling the super\\n// constructor at all. You can run the conversion tool yourself to see what it\\n// does on this file: blaze run //javascript/refactoring/es6_classes:convert.\\n\\ngoog.provide('goog.labs.format.csv');\\ngoog.provide('goog.labs.format.csv.ParseError');\\ngoog.provide('goog.labs.format.csv.Token');\\n\\ngoog.require('goog.array');\\ngoog.require('goog.asserts');\\ngoog.require('goog.debug.Error');\\ngoog.require('goog.object');\\ngoog.require('goog.string');\\ngoog.require('goog.string.newlines');\\n\\n\\n/**\\n * @define {boolean} Enable verbose debugging. This is a flag so it can be\\n * enabled in production if necessary post-compilation.  Otherwise, debug\\n * information will be stripped to minimize final code size.\\n */\\ngoog.labs.format.csv.ENABLE_VERBOSE_DEBUGGING = goog.DEBUG;\\n\\n\\n\\n/**\\n * Error thrown when parsing fails.\\n *\\n * @param {string} text The CSV source text being parsed.\\n * @param {number} index The index, in the string, of the position of the\\n *      error.\\n * @param {string=} opt_message A description of the violated parse expectation.\\n * @constructor\\n * @extends {goog.debug.Error}\\n * @final\\n */\\ngoog.labs.format.csv.ParseError = function(text, index, opt_message) {\\n  'use strict';\\n  var message;\\n\\n  /**\\n   * @type {?{line: number, column: number}} The line and column of the parse\\n   *     error.\\n   */\\n  this.position = null;\\n\\n  if (goog.labs.format.csv.ENABLE_VERBOSE_DEBUGGING) {\\n    message = opt_message || '';\\n\\n    var info = goog.labs.format.csv.ParseError.findLineInfo_(text, index);\\n    if (info) {\\n      var lineNumber = info.lineIndex + 1;\\n      var columnNumber = index - info.line.startLineIndex + 1;\\n\\n      this.position = {line: lineNumber, column: columnNumber};\\n\\n      message +=\\n          goog.string.subs(' at line %s column %s', lineNumber, columnNumber);\\n      message += '\\\\n' +\\n          goog.labs.format.csv.ParseError.getLineDebugString_(\\n              info.line.getContent(), columnNumber);\\n    }\\n  }\\n\\n  goog.labs.format.csv.ParseError.base(this, 'constructor', message);\\n};\\ngoog.inherits(goog.labs.format.csv.ParseError, goog.debug.Error);\\n\\n\\n/** @inheritDoc */\\ngoog.labs.format.csv.ParseError.prototype.name = 'ParseError';\\n\\n\\n/**\\n * Calculate the line and column for an index in a string.\\n * TODO(nnaze): Consider moving to goog.string.newlines.\\n * @param {string} str A string.\\n * @param {number} index An index into the string.\\n * @return {?{line: !goog.string.newlines.Line, lineIndex: number}} The line\\n *     and index of the line.\\n * @private\\n */\\ngoog.labs.format.csv.ParseError.findLineInfo_ = function(str, index) {\\n  'use strict';\\n  var lines = goog.string.newlines.getLines(str);\\n  var lineIndex = goog.array.findIndex(lines, function(line) {\\n    'use strict';\\n    return line.startLineIndex <= index && line.endLineIndex > index;\\n  });\\n\\n  if (typeof (lineIndex) === 'number') {\\n    var line = lines[lineIndex];\\n    return {line: line, lineIndex: lineIndex};\\n  }\\n\\n  return null;\\n};\\n\\n\\n/**\\n * Get a debug string of a line and a pointing caret beneath it.\\n * @param {string} str The string.\\n * @param {number} column The column to point at (1-indexed).\\n * @return {string} The debug line.\\n * @private\\n */\\ngoog.labs.format.csv.ParseError.getLineDebugString_ = function(str, column) {\\n  'use strict';\\n  var returnString = str + '\\\\n';\\n  returnString += goog.string.repeat(' ', column - 1) + '^';\\n  return returnString;\\n};\\n\\n\\n/**\\n * A token -- a single-character string or a sentinel.\\n * @typedef {string|!goog.labs.format.csv.Sentinels_}\\n */\\ngoog.labs.format.csv.Token;\\n\\n\\n/**\\n * Parses a CSV string to create a two-dimensional array.\\n *\\n * This function does not process header lines, etc -- such transformations can\\n * be made on the resulting array.\\n *\\n * @param {string} text The entire CSV text to be parsed.\\n * @param {boolean=} opt_ignoreErrors Whether to ignore parsing errors and\\n *      instead try to recover and keep going.\\n * @param {string=} opt_delimiter The delimiter to use. Defaults to ','\\n * @return {!Array<!Array<string>>} The parsed CSV.\\n */\\ngoog.labs.format.csv.parse = function(text, opt_ignoreErrors, opt_delimiter) {\\n  'use strict';\\n  var index = 0;  // current char offset being considered\\n\\n  var delimiter = opt_delimiter || ',';\\n  goog.asserts.assert(\\n      delimiter.length == 1, 'Delimiter must be a single character.');\\n  goog.asserts.assert(\\n      delimiter != '\\\\r' && opt_delimiter != '\\\\n',\\n      'Cannot use newline or carriage return has delimiter.');\\n\\n  var EOF = goog.labs.format.csv.Sentinels_.EOF;\\n  var EOR = goog.labs.format.csv.Sentinels_.EOR;\\n  var NEWLINE = goog.labs.format.csv.Sentinels_.NEWLINE;  // \\\\r?\\\\n\\n  var EMPTY = goog.labs.format.csv.Sentinels_.EMPTY;\\n\\n  var pushBackToken = null;  // A single-token pushback.\\n  var sawComma = false;      // Special case for terminal comma.\\n\\n  /**\\n   * Push a single token into the push-back variable.\\n   * @param {goog.labs.format.csv.Token} t Single token.\\n   */\\n  function pushBack(t) {\\n    goog.labs.format.csv.assertToken_(t);\\n    goog.asserts.assert(pushBackToken === null);\\n    pushBackToken = t;\\n  }\\n\\n  /**\\n   * @return {goog.labs.format.csv.Token} The next token in the stream.\\n   */\\n  function nextToken() {\\n    // Give the push back token if present.\\n    if (pushBackToken != null) {\\n      var c = pushBackToken;\\n      pushBackToken = null;\\n      return c;\\n    }\\n\\n    // We're done. EOF.\\n    if (index >= text.length) {\\n      return EOF;\\n    }\\n\\n    // Give the next charater.\\n    var chr = text.charAt(index++);\\n    goog.labs.format.csv.assertToken_(chr);\\n\\n    // Check if this is a newline.  If so, give the new line sentinel.\\n    var isNewline = false;\\n    if (chr == '\\\\n') {\\n      isNewline = true;\\n    } else if (chr == '\\\\r') {\\n      // This is a '\\\\r\\\\n' newline. Treat as single token, go\\n      // forward two indicies.\\n      if (index < text.length && text.charAt(index) == '\\\\n') {\\n        index++;\\n      }\\n\\n      isNewline = true;\\n    }\\n\\n    if (isNewline) {\\n      return NEWLINE;\\n    }\\n\\n    return chr;\\n  }\\n\\n  /**\\n   * Read a quoted field from input.\\n   * @return {string} The field, as a string.\\n   */\\n  function readQuotedField() {\\n    // We've already consumed the first quote by the time we get here.\\n    var start = index;\\n    var end = null;\\n\\n    for (var token = nextToken(); token != EOF; token = nextToken()) {\\n      if (token == '\\\"') {\\n        end = index - 1;\\n        token = nextToken();\\n\\n        // Two double quotes in a row.  Keep scanning.\\n        if (token == '\\\"') {\\n          end = null;\\n          continue;\\n        }\\n\\n        // End of field.  Break out.\\n        if (token == delimiter || token == EOF || token == NEWLINE) {\\n          if (token == NEWLINE) {\\n            pushBack(token);\\n          }\\n          if (token == delimiter) {\\n            sawComma = true;\\n          }\\n          break;\\n        }\\n\\n        if (!opt_ignoreErrors) {\\n          // Ignoring errors here means keep going in current field after\\n          // closing quote. E.g. \\\"ab\\\"c,d splits into abc,d\\n          throw new goog.labs.format.csv.ParseError(\\n              text, index - 1,\\n              'Unexpected character \\\"' + token + '\\\" after quote mark');\\n        } else {\\n          // Fall back to reading the rest of this field as unquoted.\\n          // Note: the rest is guaranteed not start with \\\", as that case is\\n          // eliminated above.\\n          var prefix = '\\\"' + text.substring(start, index);\\n          var suffix = readField();\\n          if (suffix == EOR) {\\n            pushBack(NEWLINE);\\n            return prefix;\\n          } else {\\n            return prefix + suffix;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (end === null) {\\n      if (!opt_ignoreErrors) {\\n        throw new goog.labs.format.csv.ParseError(\\n            text, text.length - 1, 'Unexpected end of text after open quote');\\n      } else {\\n        end = text.length;\\n      }\\n    }\\n\\n    // Take substring, combine double quotes.\\n    return text.substring(start, end).replace(/\\\"\\\"/g, '\\\"');\\n  }\\n\\n  /**\\n   * Read a field from input.\\n   * @return {string|!goog.labs.format.csv.Sentinels_} The field, as a string,\\n   *     or a sentinel (if applicable).\\n   */\\n  function readField() {\\n    var start = index;\\n    var didSeeComma = sawComma;\\n    sawComma = false;\\n    var token = nextToken();\\n    if (token == EMPTY) {\\n      return EOR;\\n    }\\n    if (token == EOF || token == NEWLINE) {\\n      if (didSeeComma) {\\n        pushBack(EMPTY);\\n        return '';\\n      }\\n      return EOR;\\n    }\\n\\n    // This is the beginning of a quoted field.\\n    if (token == '\\\"') {\\n      return readQuotedField();\\n    }\\n\\n    while (true) {\\n      // This is the end of line or file.\\n      if (token == EOF || token == NEWLINE) {\\n        pushBack(token);\\n        break;\\n      }\\n\\n      // This is the end of record.\\n      if (token == delimiter) {\\n        sawComma = true;\\n        break;\\n      }\\n\\n      if (token == '\\\"' && !opt_ignoreErrors) {\\n        throw new goog.labs.format.csv.ParseError(\\n            text, index - 1, 'Unexpected quote mark');\\n      }\\n\\n      token = nextToken();\\n    }\\n\\n\\n    var returnString = (token == EOF) ?\\n        text.substring(start) :  // Return to end of file.\\n        text.substring(start, index - 1);\\n\\n    return returnString.replace(/[\\\\r\\\\n]+/g, '');  // Squash any CRLFs.\\n  }\\n\\n  /**\\n   * Read the next record.\\n   * @return {!Array<string>|!goog.labs.format.csv.Sentinels_} A single record\\n   *     with multiple fields.\\n   */\\n  function readRecord() {\\n    if (index >= text.length) {\\n      return EOF;\\n    }\\n    var record = [];\\n    for (var field = readField(); field != EOR; field = readField()) {\\n      record.push(field);\\n    }\\n    return record;\\n  }\\n\\n  // Read all records and return.\\n  var records = [];\\n  for (var record = readRecord(); record != EOF; record = readRecord()) {\\n    records.push(record);\\n  }\\n  return records;\\n};\\n\\n\\n/**\\n * Sentinel tracking objects.\\n * @enum {!Object}\\n * @private\\n */\\ngoog.labs.format.csv.Sentinels_ = {\\n  /** Empty field */\\n  EMPTY: {},\\n\\n  /** End of file */\\n  EOF: {},\\n\\n  /** End of record */\\n  EOR: {},\\n\\n  /** Newline. \\\\r?\\\\n */\\n  NEWLINE: {}\\n};\\n\\n\\n/**\\n * @param {string} str A string.\\n * @return {boolean} Whether the string is a single character.\\n * @private\\n */\\ngoog.labs.format.csv.isCharacterString_ = function(str) {\\n  'use strict';\\n  return typeof str === 'string' && str.length == 1;\\n};\\n\\n\\n/**\\n * Assert the parameter is a token.\\n * @param {*} o What should be a token.\\n * @throws {goog.asserts.AssertionError} If {@ code} is not a token.\\n * @private\\n */\\ngoog.labs.format.csv.assertToken_ = function(o) {\\n  'use strict';\\n  if (typeof o === 'string') {\\n    goog.asserts.assertString(o);\\n    goog.asserts.assert(\\n        goog.labs.format.csv.isCharacterString_(o),\\n        'Should be a string of length 1 or a sentinel.');\\n  } else {\\n    goog.asserts.assert(\\n        goog.object.containsValue(goog.labs.format.csv.Sentinels_, o),\\n        'Should be a string of length 1 or a sentinel.');\\n  }\\n};\\n\"],\n\"names\":[\"goog\",\"provide\",\"require\",\"labs\",\"format\",\"csv\",\"ENABLE_VERBOSE_DEBUGGING\",\"DEBUG\",\"ParseError\",\"goog.labs.format.csv.ParseError\",\"text\",\"index\",\"opt_message\",\"message\",\"position\",\"info\",\"findLineInfo_\",\"lineNumber\",\"lineIndex\",\"columnNumber\",\"line\",\"startLineIndex\",\"column\",\"string\",\"subs\",\"getLineDebugString_\",\"getContent\",\"base\",\"inherits\",\"debug\",\"Error\",\"prototype\",\"name\",\"goog.labs.format.csv.ParseError.findLineInfo_\",\"str\",\"lines\",\"newlines\",\"getLines\",\"array\",\"findIndex\",\"endLineIndex\",\"goog.labs.format.csv.ParseError.getLineDebugString_\",\"returnString\",\"repeat\",\"Token\",\"parse\",\"goog.labs.format.csv.parse\",\"opt_ignoreErrors\",\"opt_delimiter\",\"delimiter\",\"asserts\",\"assert\",\"length\",\"EOF\",\"Sentinels_\",\"EOR\",\"NEWLINE\",\"EMPTY\",\"pushBackToken\",\"sawComma\",\"pushBack\",\"t\",\"assertToken_\",\"nextToken\",\"c\",\"chr\",\"charAt\",\"isNewline\",\"readQuotedField\",\"start\",\"end\",\"token\",\"prefix\",\"substring\",\"suffix\",\"readField\",\"replace\",\"didSeeComma\",\"readRecord\",\"record\",\"field\",\"push\",\"records\",\"isCharacterString_\",\"goog.labs.format.csv.isCharacterString_\",\"goog.labs.format.csv.assertToken_\",\"o\",\"assertString\",\"object\",\"containsValue\"]\n}\n"]
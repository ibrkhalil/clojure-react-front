["^ ","~:output",["^ ","~:js","goog.provide('promesa.core');\r\npromesa.core.Promise = promesa.impl.Promise;\r\n/**\r\n * Schedule a callable to be executed after the `ms` delay\r\n *   is reached.\r\n * \r\n *   In JVM it uses a scheduled executor service and in JS\r\n *   it uses the `setTimeout` function.\r\n */\r\npromesa.core.schedule = (function promesa$core$schedule(ms,func){\r\nreturn promesa.impl.scheduler.schedule(ms,func);\r\n});\r\n/**\r\n * Return a resolved promise with provided value.\r\n */\r\npromesa.core.resolved = (function promesa$core$resolved(v){\r\nreturn promesa.impl.resolved(v);\r\n});\r\n/**\r\n * Return a rejected promise with provided reason.\r\n */\r\npromesa.core.rejected = (function promesa$core$rejected(v){\r\nreturn promesa.impl.rejected(v);\r\n});\r\n/**\r\n * The promise constructor.\r\n */\r\npromesa.core.promise = (function promesa$core$promise(v){\r\nreturn promesa.protocols._promise(v);\r\n});\r\n/**\r\n * Return true if `v` is a promise instance.\r\n */\r\npromesa.core.promise_QMARK_ = (function promesa$core$promise_QMARK_(v){\r\nreturn (v instanceof promesa.core.Promise);\r\n});\r\n/**\r\n * Returns true if promise `p` is already fulfilled.\r\n */\r\npromesa.core.resolved_QMARK_ = (function promesa$core$resolved_QMARK_(p){\r\nreturn promesa.protocols._resolved_QMARK_(p);\r\n});\r\n/**\r\n * Returns true if promise `p` is already rejected.\r\n */\r\npromesa.core.rejected_QMARK_ = (function promesa$core$rejected_QMARK_(p){\r\nreturn promesa.protocols._rejected_QMARK_(p);\r\n});\r\n/**\r\n * Returns true if promise `p` is stil pending.\r\n */\r\npromesa.core.pending_QMARK_ = (function promesa$core$pending_QMARK_(p){\r\nreturn promesa.protocols._pending_QMARK_(p);\r\n});\r\n/**\r\n * Returns the current promise value.\r\n */\r\npromesa.core.extract = (function promesa$core$extract(p){\r\nreturn promesa.protocols._extract(p);\r\n});\r\n/**\r\n * Returns true if promise `p` is already done.\r\n */\r\npromesa.core.done_QMARK_ = cljs.core.complement(promesa.core.pending_QMARK_);\r\n/**\r\n * Apply a function to the promise value and\r\n *   return a new promise with the result.\r\n */\r\npromesa.core.map = (function promesa$core$map(f,p){\r\nreturn promesa.protocols._map(p,f);\r\n});\r\n/**\r\n * Same as `map` but removes one level of\r\n *   promise neesting. Useful when the map function\r\n *   returns a promise instead of value.\r\n * \r\n *   In JS environment this function is analogous\r\n *   to `map` because the promise abstraction overloads\r\n *   the `map` operator.\r\n */\r\npromesa.core.mapcat = (function promesa$core$mapcat(f,p){\r\nreturn promesa.protocols._bind(p,f);\r\n});\r\n/**\r\n * A chain helper for promises.\r\n */\r\npromesa.core.bind = (function promesa$core$bind(p,f){\r\nreturn promesa.protocols._bind(p,f);\r\n});\r\n/**\r\n * Similar to `map` but with parameters inverted\r\n *   for convenience and for familiarity with\r\n *   javascript's promises `.then` operator.\r\n * \r\n *   Unlike Clojure's `map`, will resolve any promises\r\n *   returned  by `f`.\r\n */\r\npromesa.core.then = (function promesa$core$then(p,f){\r\nreturn promesa.protocols._map(p,f);\r\n});\r\n/**\r\n * Like then but accepts multiple parameters.\r\n */\r\npromesa.core.chain = (function promesa$core$chain(var_args){\r\nvar args__4824__auto__ = [];\r\nvar len__4818__auto___26937 = arguments.length;\r\nvar i__4819__auto___26938 = (0);\r\nwhile(true){\r\nif((i__4819__auto___26938 < len__4818__auto___26937)){\r\nargs__4824__auto__.push((arguments[i__4819__auto___26938]));\r\n\r\nvar G__26939 = (i__4819__auto___26938 + (1));\r\ni__4819__auto___26938 = G__26939;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nvar argseq__4825__auto__ = ((((1) < args__4824__auto__.length))?(new cljs.core.IndexedSeq(args__4824__auto__.slice((1)),(0),null)):null);\r\nreturn promesa.core.chain.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4825__auto__);\r\n});\r\n\r\n(promesa.core.chain.cljs$core$IFn$_invoke$arity$variadic = (function (p,funcs){\r\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__26792_SHARP_,p2__26793_SHARP_){\r\nreturn promesa.core.then(p1__26792_SHARP_,p2__26793_SHARP_);\r\n}),p,funcs);\r\n}));\r\n\r\n(promesa.core.chain.cljs$lang$maxFixedArity = (1));\r\n\r\n/** @this {Function} */\r\n(promesa.core.chain.cljs$lang$applyTo = (function (seq26794){\r\nvar G__26797 = cljs.core.first(seq26794);\r\nvar seq26794__$1 = cljs.core.next(seq26794);\r\nvar self__4805__auto__ = this;\r\nreturn self__4805__auto__.cljs$core$IFn$_invoke$arity$variadic(G__26797,seq26794__$1);\r\n}));\r\n\r\npromesa.core.branch = (function promesa$core$branch(p,success,failure){\r\nreturn promesa.protocols._catch(promesa.protocols._map(p,success),failure);\r\n});\r\n/**\r\n * Catch all promise chain helper.\r\n */\r\npromesa.core.catch$ = (function promesa$core$catch(var_args){\r\nvar G__26838 = arguments.length;\r\nswitch (G__26838) {\r\ncase 2:\r\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ncase 3:\r\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(promesa.core.catch$.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\r\nreturn promesa.protocols._catch(p,f);\r\n}));\r\n\r\n(promesa.core.catch$.cljs$core$IFn$_invoke$arity$3 = (function (p,pred_or_type,f){\r\nvar accept_QMARK_ = ((cljs.core.ifn_QMARK_(pred_or_type))?pred_or_type:(function (p1__26825_SHARP_){\r\nreturn (p1__26825_SHARP_ instanceof pred_or_type);\r\n}));\r\nreturn promesa.protocols._catch(p,(function (e){\r\nif(cljs.core.truth_((accept_QMARK_.cljs$core$IFn$_invoke$arity$1 ? accept_QMARK_.cljs$core$IFn$_invoke$arity$1(e) : accept_QMARK_.call(null,e)))){\r\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(e) : f.call(null,e));\r\n} else {\r\nreturn promesa.impl.rejected(e);\r\n}\r\n}));\r\n}));\r\n\r\n(promesa.core.catch$.cljs$lang$maxFixedArity = 3);\r\n\r\n/**\r\n * Same as `catch` but with parameters inverted.\r\n */\r\npromesa.core.error = (function promesa$core$error(var_args){\r\nvar G__26884 = arguments.length;\r\nswitch (G__26884) {\r\ncase 2:\r\nreturn promesa.core.error.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ncase 3:\r\nreturn promesa.core.error.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(promesa.core.error.cljs$core$IFn$_invoke$arity$2 = (function (f,p){\r\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$2(p,f);\r\n}));\r\n\r\n(promesa.core.error.cljs$core$IFn$_invoke$arity$3 = (function (f,type,p){\r\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$3(p,type,f);\r\n}));\r\n\r\n(promesa.core.error.cljs$lang$maxFixedArity = 3);\r\n\r\n/**\r\n * A short alias for `error` function.\r\n */\r\npromesa.core.err = promesa.core.error;\r\n/**\r\n * Attach handler to promise that will be\r\n *   executed independently if promise is\r\n *   resolved or rejected.\r\n */\r\npromesa.core.finally$ = (function promesa$core$finally(p,callback){\r\nreturn p.lastly(callback);\r\n});\r\n/**\r\n * Given an array of promises, return a promise\r\n *   that is fulfilled  when all the items in the\r\n *   array are fulfilled.\r\n * \r\n *   Example:\r\n * \r\n *   (-> (all [(promise :first-promise)\r\n *          (promise :second-promise)]\r\n *    (then (fn [[first-result second-result]]))\r\n *     (println (str first-result \", \" second-result)\r\n * \r\n *   Will print out\r\n *   :first-promise, :second-promise.\r\n * \r\n *   If at least one of the promises is rejected, the resulting promise will be\r\n *   rejected.\r\n */\r\npromesa.core.all = (function promesa$core$all(promises){\r\nreturn promesa.core.then(promesa.core.Promise.all(cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(promises)),cljs.core.vec);\r\n});\r\n/**\r\n * Given an array of promises, return a promise\r\n *   that is fulfilled when first one item in the\r\n *   array is fulfilled.\r\n */\r\npromesa.core.any = (function promesa$core$any(promises){\r\nreturn promesa.core.Promise.any(cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(promises));\r\n});\r\n/**\r\n * Cancel the promise.\r\n */\r\npromesa.core.cancel_BANG_ = (function promesa$core$cancel_BANG_(p){\r\npromesa.protocols._cancel(p);\r\n\r\nreturn p;\r\n});\r\n/**\r\n * Return true if `v` is a cancelled promise.\r\n */\r\npromesa.core.cancelled_QMARK_ = (function promesa$core$cancelled_QMARK_(v){\r\nreturn promesa.protocols._cancelled_QMARK_(v);\r\n});\r\n/**\r\n * Given a function that accepts a callback as the last argument return other\r\n *   function that returns a promise. Callback is expected to take single\r\n *   parameter (result of a computation).\r\n */\r\npromesa.core.promisify = (function promesa$core$promisify(callable){\r\nreturn (function() { \r\nvar G__26953__delegate = function (args){\r\nreturn promesa.core.promise((function (resolve,reject){\r\nvar args__$1 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.vec(args),resolve);\r\ntry{return cljs.core.apply.cljs$core$IFn$_invoke$arity$2(callable,args__$1);\r\n}catch (e26895){if((e26895 instanceof Error)){\r\nvar e = e26895;\r\nreturn (reject.cljs$core$IFn$_invoke$arity$1 ? reject.cljs$core$IFn$_invoke$arity$1(e) : reject.call(null,e));\r\n} else {\r\nthrow e26895;\r\n\r\n}\r\n}}));\r\n};\r\nvar G__26953 = function (var_args){\r\nvar args = null;\r\nif (arguments.length > 0) {\r\nvar G__26954__i = 0, G__26954__a = new Array(arguments.length -  0);\r\nwhile (G__26954__i < G__26954__a.length) {G__26954__a[G__26954__i] = arguments[G__26954__i + 0]; ++G__26954__i;}\r\n  args = new cljs.core.IndexedSeq(G__26954__a,0,null);\r\n} \r\nreturn G__26953__delegate.call(this,args);};\r\nG__26953.cljs$lang$maxFixedArity = 0;\r\nG__26953.cljs$lang$applyTo = (function (arglist__26955){\r\nvar args = cljs.core.seq(arglist__26955);\r\nreturn G__26953__delegate(args);\r\n});\r\nG__26953.cljs$core$IFn$_invoke$arity$variadic = G__26953__delegate;\r\nreturn G__26953;\r\n})()\r\n;\r\n});\r\n/**\r\n * Returns a cancellable promise that will be fulfilled\r\n *   with this promise's fulfillment value or rejection reason.\r\n *   However, if this promise is not fulfilled or rejected\r\n *   within `ms` milliseconds, the returned promise is cancelled\r\n *   with a TimeoutError\r\n */\r\npromesa.core.timeout = (function promesa$core$timeout(var_args){\r\nvar G__26903 = arguments.length;\r\nswitch (G__26903) {\r\ncase 2:\r\nreturn promesa.core.timeout.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ncase 3:\r\nreturn promesa.core.timeout.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(promesa.core.timeout.cljs$core$IFn$_invoke$arity$2 = (function (p,t){\r\nreturn p.timeout(t);\r\n}));\r\n\r\n(promesa.core.timeout.cljs$core$IFn$_invoke$arity$3 = (function (p,t,v){\r\nreturn p.timeout(t,v);\r\n}));\r\n\r\n(promesa.core.timeout.cljs$lang$maxFixedArity = 3);\r\n\r\n/**\r\n * Given a timeout in miliseconds and optional\r\n *   value, returns a promise that will fulfilled\r\n *   with provided value (or nil) after the\r\n *   time is reached.\r\n */\r\npromesa.core.delay = (function promesa$core$delay(var_args){\r\nvar G__26912 = arguments.length;\r\nswitch (G__26912) {\r\ncase 1:\r\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\r\n\r\nbreak;\r\ncase 2:\r\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(promesa.core.delay.cljs$core$IFn$_invoke$arity$1 = (function (t){\r\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$2(t,null);\r\n}));\r\n\r\n(promesa.core.delay.cljs$core$IFn$_invoke$arity$2 = (function (t,v){\r\nreturn promesa.core.promise((function (resolve,reject){\r\nreturn promesa.core.schedule(t,(function (){\r\nreturn (resolve.cljs$core$IFn$_invoke$arity$1 ? resolve.cljs$core$IFn$_invoke$arity$1(v) : resolve.call(null,v));\r\n}));\r\n}));\r\n}));\r\n\r\n(promesa.core.delay.cljs$lang$maxFixedArity = 2);\r\n\r\n/**\r\n * A helper for start promise chain without worry about\r\n *   synchronous or asynchronous exceptions. Returns a promise\r\n *   resolved with the return value of the callback.\r\n */\r\npromesa.core.attempt = (function promesa$core$attempt(callback){\r\nreturn promesa.core.promise((function (resolve){\r\nvar G__26918 = (callback.cljs$core$IFn$_invoke$arity$0 ? callback.cljs$core$IFn$_invoke$arity$0() : callback.call(null));\r\nreturn (resolve.cljs$core$IFn$_invoke$arity$1 ? resolve.cljs$core$IFn$_invoke$arity$1(G__26918) : resolve.call(null,G__26918));\r\n}));\r\n});\r\npromesa.core.await$ = (function promesa$core$await(var_args){\r\nvar args__4824__auto__ = [];\r\nvar len__4818__auto___26978 = arguments.length;\r\nvar i__4819__auto___26979 = (0);\r\nwhile(true){\r\nif((i__4819__auto___26979 < len__4818__auto___26978)){\r\nargs__4824__auto__.push((arguments[i__4819__auto___26979]));\r\n\r\nvar G__26980 = (i__4819__auto___26979 + (1));\r\ni__4819__auto___26979 = G__26980;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nvar argseq__4825__auto__ = ((((0) < args__4824__auto__.length))?(new cljs.core.IndexedSeq(args__4824__auto__.slice((0)),(0),null)):null);\r\nreturn promesa.core.await$.cljs$core$IFn$_invoke$arity$variadic(argseq__4825__auto__);\r\n});\r\n\r\n(promesa.core.await$.cljs$core$IFn$_invoke$arity$variadic = (function (args){\r\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"Should be only used in alet macro.\",cljs.core.PersistentArrayMap.EMPTY);\r\n}));\r\n\r\n(promesa.core.await$.cljs$lang$maxFixedArity = (0));\r\n\r\n/** @this {Function} */\r\n(promesa.core.await$.cljs$lang$applyTo = (function (seq26926){\r\nvar self__4806__auto__ = this;\r\nreturn self__4806__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq26926));\r\n}));\r\n\r\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","promesa/core.cljc","~:line",25,"~:column",5,"~:end-line",25,"~:end-column",17],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha","~$react","~$module$node_modules$react$index","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.core","~$cljs.core"],"~:use-macros",null,"~:excludes",["~#set",["~$map","~$delay","~$mapcat","~$await","~$spread","~$promise"]],"~:name","~$promesa.core","~:reader-aliases",["^ "],"~:op","~:ns","~:imports",null,"~:requires",["^ ","~$promesa.protocols","^X","~$pt","^X","~$promesa.impl","^Z","~$impl","^Z","~$promesa.impl.scheduler","^10","~$ps","^10","^G","^G","~$goog","^12"],"~:seen",["^J",["~:require"]],"~:uses",null,"~:require-macros",["^ ","^G","^G"],"~:form",["~#list",["~$ns","^R",["^18",["~:refer-clojure","~:exclude",["^L","^O","^P","^N","^K","^M"]]],["^18",["^14",["^X","~:as","^Y"],["^Z","^1<","^["],["^10","^1<","^11"]]]]],"~:flags",["^ ","^14",["^J",[]]],"~:js-deps",["^ "],"~:deps",["^12","^G","^X","^Z","^10"]],"^U","^R","~:resource-id",["~:shadow.build.classpath/resource","promesa/core.cljc"],"~:compiled-at",1634348946659,"^S",["^ ","^X","^X","^Y","^X","^Z","^Z","^[","^Z","^10","^10","^11","^10","^G","^G","^12","^12"],"~:resource-name","promesa/core.cljc","~:warnings",[],"~:source",";; Copyright (c) 2015-2016 Andrey Antukh <niwi@niwi.nz>\n;; All rights reserved.\n;;\n;; Redistribution and use in source and binary forms, with or without\n;; modification, are permitted provided that the following conditions\n;; are met:\n;;\n;; 1. Redistributions of source code must retain the above copyright\n;;    notice, this list of conditions and the following disclaimer.\n;; 2. Redistributions in binary form must reproduce the above copyright\n;;    notice, this list of conditions and the following disclaimer in the\n;;    documentation and/or other materials provided with the distribution.\n;;\n;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n;; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n;; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n;; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n;; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n(ns promesa.core\n  (:refer-clojure :exclude [delay spread promise await map mapcat])\n  (:require [promesa.protocols :as pt]\n            [promesa.impl :as impl]\n            [promesa.impl.scheduler :as ps])\n  #?(:clj\n     (:import java.util.concurrent.CompletableFuture\n              java.util.concurrent.CompletionStage)))\n\n;; --- Global Constants\n\n#?(:clj\n   (defn set-executor!\n     \"Replace the default executor instance with\n     your own instance.\"\n     [executor]\n     (alter-var-root #'impl/+executor+ (constantly executor))))\n\n#?(:cljs (def ^:const Promise impl/Promise))\n\n;; --- Scheduling helpers\n\n(defn schedule\n  \"Schedule a callable to be executed after the `ms` delay\n  is reached.\n\n  In JVM it uses a scheduled executor service and in JS\n  it uses the `setTimeout` function.\"\n  [ms func]\n  (ps/schedule ms func))\n\n;; --- Promise\n\n(defn resolved\n  \"Return a resolved promise with provided value.\"\n  [v]\n  (impl/resolved v))\n\n(defn rejected\n  \"Return a rejected promise with provided reason.\"\n  [v]\n  (impl/rejected v))\n\n(defn promise\n  \"The promise constructor.\"\n  [v]\n  (pt/-promise v))\n\n(defn promise?\n  \"Return true if `v` is a promise instance.\"\n  [v]\n  #?(:clj (instance? CompletionStage v)\n     :cljs (instance? Promise v)))\n\n;; Predicates\n\n(defn resolved?\n  \"Returns true if promise `p` is already fulfilled.\"\n  [p]\n  (pt/-resolved? p))\n\n(defn rejected?\n  \"Returns true if promise `p` is already rejected.\"\n  [p]\n  (pt/-rejected? p))\n\n(defn pending?\n  \"Returns true if promise `p` is stil pending.\"\n  [p]\n  (pt/-pending? p))\n\n(defn extract\n  \"Returns the current promise value.\"\n  [p]\n  (pt/-extract p))\n\n(def done?\n  \"Returns true if promise `p` is already done.\"\n  (complement pending?))\n\n;; Chaining\n\n(defn map\n  \"Apply a function to the promise value and\n  return a new promise with the result.\"\n  [f p]\n  (pt/-map p f))\n\n(defn mapcat\n  \"Same as `map` but removes one level of\n  promise neesting. Useful when the map function\n  returns a promise instead of value.\n\n  In JS environment this function is analogous\n  to `map` because the promise abstraction overloads\n  the `map` operator.\"\n  [f p]\n  (pt/-bind p f))\n\n(defn bind\n  \"A chain helper for promises.\"\n  [p f]\n  (pt/-bind p f))\n\n(defn then\n  \"Similar to `map` but with parameters inverted\n  for convenience and for familiarity with\n  javascript's promises `.then` operator.\n\n  Unlike Clojure's `map`, will resolve any promises\n  returned  by `f`.\"\n  [p f]\n  #?(:cljs (pt/-map p f)\n     :clj  (pt/-bind p (fn promise-wrap [in]\n                         (let [out (f in)]\n                           (if (promise? out)\n                             out\n                             (promise out)))))))\n\n(defn chain\n  \"Like then but accepts multiple parameters.\"\n  [p & funcs]\n  (reduce #(then %1 %2) p funcs))\n\n(defn branch\n  [p success failure]\n  (-> p\n      (pt/-map success)\n      (pt/-catch failure)))\n\n(defn catch\n  \"Catch all promise chain helper.\"\n  ([p f]\n   (pt/-catch p f))\n  ([p pred-or-type f]\n   (let [accept? (if (ifn? pred-or-type)\n                   pred-or-type\n                   #(instance? pred-or-type %))]\n     (pt/-catch p (fn [e]\n                    (if (accept? e)\n                      (f e)\n                      (impl/rejected e)))))))\n\n(defn error\n  \"Same as `catch` but with parameters inverted.\"\n  ([f p] (catch p f))\n  ([f type p] (catch p type f)))\n\n(def err\n  \"A short alias for `error` function.\"\n  error)\n\n(defn finally\n  \"Attach handler to promise that will be\n  executed independently if promise is\n  resolved or rejected.\"\n  [p callback]\n  #?(:clj (-> p\n              (then (fn [_] (callback)))\n              (catch (fn [_] (callback))))\n     :cljs (.lastly p callback)))\n\n(defn all\n  \"Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \\\", \\\" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected.\"\n  [promises]\n  #?(:cljs (-> (.all Promise (into-array promises))\n               (then vec))\n     :clj (let [promises (clojure.core/map pt/-promise promises)]\n            (then (->> (into-array CompletableFuture promises)\n                       (CompletableFuture/allOf))\n                  (fn [_]\n                    (mapv pt/-extract promises))))))\n\n(defn any\n  \"Given an array of promises, return a promise\n  that is fulfilled when first one item in the\n  array is fulfilled.\"\n  [promises]\n  #?(:cljs (.any Promise (into-array promises))\n     :clj (->> (clojure.core/map pt/-promise promises)\n               (into-array CompletableFuture)\n               (CompletableFuture/anyOf))))\n\n;; Cancellation\n\n(defn cancel!\n  \"Cancel the promise.\"\n  [p]\n  (pt/-cancel p)\n  p)\n\n(defn cancelled?\n  \"Return true if `v` is a cancelled promise.\"\n  [v]\n  (pt/-cancelled? v))\n\n;; Utils\n\n(defn promisify\n  \"Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation).\"\n  [callable]\n  (fn [& args]\n    (promise (fn [resolve reject]\n               (let [args (-> (vec args)\n                              (conj resolve))]\n                 (try\n                   (apply callable args)\n                   (catch #?(:clj Throwable :cljs js/Error) e\n                       (reject e))))))))\n\n#?(:cljs\n   (defn timeout\n     \"Returns a cancellable promise that will be fulfilled\n     with this promise's fulfillment value or rejection reason.\n     However, if this promise is not fulfilled or rejected\n     within `ms` milliseconds, the returned promise is cancelled\n     with a TimeoutError\"\n     ([p t] (.timeout p t))\n     ([p t v] (.timeout p t v))))\n\n(defn delay\n  \"Given a timeout in miliseconds and optional\n  value, returns a promise that will fulfilled\n  with provided value (or nil) after the\n  time is reached.\"\n  ([t] (delay t nil))\n  ([t v]\n   #?(:cljs (promise (fn [resolve reject]\n                       (schedule t #(resolve v))))\n\n      :clj  (let [p (CompletableFuture.)]\n              (schedule t #(.complete p v))\n              p))))\n\n(defn attempt\n  \"A helper for start promise chain without worry about\n  synchronous or asynchronous exceptions. Returns a promise\n  resolved with the return value of the callback.\"\n  [callback]\n  #?(:cljs (promise (fn [resolve] (resolve (callback))))\n     :clj  (promise (fn [resolve reject]\n                      (let [result (callback)]\n                        (if (promise? result)\n                          (then result resolve)\n                          (resolve result)))))))\n\n#?(:clj\n   (defmacro do*\n     \"A sugar syntax on top of `attempt`.\"\n     [& body]\n     `(attempt #(do ~@body))))\n\n(defn await\n  [& args]\n  (throw (ex-info \"Should be only used in alet macro.\" {})))\n\n#?(:clj\n   (defmacro alet\n     \"A `let` alternative that always returns promise and allows\n     use `await` marker function in order to emulate the async/await\n     syntax and make the let expression look like synchronous where\n     async operations are performed.\"\n     [bindings & body]\n     (let [await# `await]\n       (->> (reverse (partition 2 bindings))\n            (reduce (fn [acc [l r]]\n                      (if (and (coll? r)\n                               (symbol? (first r))\n                               (not= \".\" (subs (name (first r)) 0 1)))\n                        `(if (= ~await# ~(first r))\n                           (bind ~(second r) (fn [~l] ~acc))\n                           (let [~l ~r] ~acc))\n                        `(let [~l ~r] ~acc)))\n                    `(promise (do ~@body)))))))\n","~:reader-features",["^J",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["promesa.core/Promise","promesa.impl/Promise","promesa.core/schedule","ms","func","promesa.impl.scheduler/schedule","promesa.core/resolved","v","promesa.impl/resolved","promesa.core/rejected","promesa.impl/rejected","promesa.core/promise","promesa.protocols/-promise","promesa.core/promise?","promesa.core/resolved?","p","promesa.protocols/-resolved?","promesa.core/rejected?","promesa.protocols/-rejected?","promesa.core/pending?","promesa.protocols/-pending?","promesa.core/extract","promesa.protocols/-extract","promesa.core/done?","cljs.core/complement","promesa.core/map","f","promesa.protocols/-map","promesa.core/mapcat","promesa.protocols/-bind","promesa.core/bind","promesa.core/then","var_args","args__4824__auto__","len__4818__auto__","i__4819__auto__","argseq__4825__auto__","cljs.core/IndexedSeq","promesa.core/chain","seq26794","G__26797","cljs.core/first","cljs.core/next","self__4805__auto__","funcs","p1__26792#","p2__26793#","cljs.core.reduce","promesa.core/branch","success","failure","promesa.protocols/-catch","G__26838","promesa.core/catch","js/Error","pred-or-type","accept?","p1__26825#","cljs.core/ifn?","e","G__26884","promesa.core/error","promesa.core.catch$","type","promesa.core/err","promesa.core/finally","callback","promesa.core/all","promises","cljs.core.into_array","cljs.core/vec","promesa.core/any","promesa.core/cancel!","promesa.protocols/-cancel","promesa.core/cancelled?","promesa.protocols/-cancelled?","promesa.core/promisify","callable","args","resolve","reject","cljs.core.conj","e26895","cljs.core.apply","G__26903","promesa.core/timeout","t","G__26912","promesa.core/delay","promesa.core.delay","promesa.core/attempt","G__26918","promesa.core/await","seq26926","self__4806__auto__","cljs.core/seq","cljs.core.ex_info"]],"~:used-vars",["^J",["~$promesa.core/promise","~$promesa.protocols/-cancel","~$promesa.impl.scheduler/schedule","~$promesa.core/promisify","~$promesa.core/mapcat","~$promesa.protocols/-map","~$promesa.core/Promise","~$promesa.core/catch","~$cljs.core/ifn?","~$promesa.impl/Promise","~$cljs.core/into-array","~$cljs.core/IndexedSeq","~$promesa.core/extract","~$cljs.core/reduce","~$cljs.core/seq","~$cljs.core/apply","~$promesa.core/rejected?","~$promesa.core/branch","~$promesa.core/rejected","~$promesa.core/attempt","~$promesa.protocols/-promise","~$promesa.impl/rejected","~$promesa.core/bind","~$cljs.core/conj","~$promesa.protocols/-extract","~$promesa.core/resolved?","~$promesa.core/map","~$promesa.core/all","~$promesa.core/cancelled?","~$promesa.core/resolved","~$promesa.protocols/-cancelled?","~$promesa.core/pending?","~$promesa.protocols/-resolved?","~$promesa.impl/resolved","~$promesa.core/error","~$cljs.core/ex-info","~$promesa.protocols/-pending?","~$promesa.core/cancel!","~$promesa.core/finally","~$promesa.core/schedule","~$promesa.core/done?","~$cljs.core/next","~$cljs.core/vec","~$promesa.core/then","~$promesa.core/any","~$cljs.core/complement","~$promesa.protocols/-rejected?","~$promesa.core/delay","~$promesa.core/chain","~$promesa.core/await","~$promesa.core/timeout","~$promesa.protocols/-catch","~$cljs.core/first","~$promesa.core/promise?","~$promesa.core/err","~$promesa.protocols/-bind","~$js/Error"]]],"~:cache-keys",["~#cmap",[["^1A","goog/dom/tagname.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^J",[]],"~:deps-syms",["^12","~$goog.dom.HtmlElement"]]],["^1A","goog/math/math.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","~$goog.array","~$goog.asserts"]]],["^1A","goog/html/trustedtypes.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12"]]],["^1A","goog/labs/useragent/browser.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^35","~$goog.labs.userAgent.util","~$goog.object","~$goog.string.internal"]]],["^1A","goog/html/safeurl.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^36","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^39"]]],["^1A","goog/array/array.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^36"]]],["~:shadow.build.npm/resource","node_modules/bluebird/js/browser/bluebird.js"],["e8091a4577ab6b32c9fa13d5dfc59db052218e1e","4e9614cdc0e2c223ef717009a8fd70c2c8df01cc","e8912727f5d0ae9a15211b9a9dce108fd443c815","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["~$shadow.js","~$module$node_modules$process$browser"]]],["^1A","goog/debug/error.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12"]]],["^1A","promesa/impl/scheduler.cljc"],["72c39dc84c953e2d6cc8bf760e61be7302042487","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^G","^X"]]],["^1A","promesa/impl.cljc"],["72c39dc84c953e2d6cc8bf760e61be7302042487","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^G","^X","~$org.bluebird"]]],["^1A","goog/dom/nodetype.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12"]]],["^1A","goog/string/typedstring.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12"]]],["^1A","shadow/js.js"],["b28862fc554bfc34b377dffd1a5257e3d9ce1aea","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12"]]],["^1A","goog/object/object.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12"]]],["^1A","goog/dom/asserts.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^36"]]],"~:SHADOW-TIMESTAMP",[1633630520000,1633630520000,1633630489000],["^1A","goog/math/long.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^36","~$goog.reflect"]]],["^1A","goog/html/trustedresourceurl.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^36","~$goog.fs.blob","^3:","~$goog.html.SafeScript","~$goog.html.trustedtypes","^3<","^3=","^3>","^3?"]]],["^1A","goog/string/internal.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12"]]],["^1A","goog/functions/functions.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12"]]],["^1A","goog/html/safestyle.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^35","^36","~$goog.html.SafeUrl","^3>","^3?","^39"]]],["^1A","goog/dom/safe.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^36","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^3G","~$goog.html.SafeStyle","^3I","^3;","~$goog.html.uncheckedconversions","^3>","^39"]]],["^1A","goog/structs/map.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^1A","goog/html/safehtml.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^35","^36","~$goog.dom.TagName","~$goog.dom.tags","^3G","^3M","~$goog.html.SafeStyleSheet","^3I","^3;","^3H","^3<","^3=","~$goog.labs.userAgent.browser","^38","^3>","^3?","^39"]]],["^1A","goog/dom/tags.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^38"]]],["^1A","goog/fs/blob.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^35"]]],["^1A","goog/asserts/asserts.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1A","goog/uri/uri.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^35","^36","~$goog.string","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1A","goog/i18n/bidi.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12"]]],["^3@","node_modules/process/browser.js"],["e8091a4577ab6b32c9fa13d5dfc59db052218e1e","4e9614cdc0e2c223ef717009a8fd70c2c8df01cc","015769d0c950757ef11a04033404e3d6ea739c58","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^3A"]]],["^1A","goog/fs/url.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12"]]],["^1A","goog/base.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",[]]],["^1A","promesa/core.cljc"],["72c39dc84c953e2d6cc8bf760e61be7302042487","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^G","^X","^Z","^10"]]],["^1A","goog/structs/structs.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^35","^38"]]],["^1A","org/bluebird.cljs"],["4323f8e603a952cae34c4c6db04141e97928434f","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^G","~$module$node_modules$bluebird$js$browser$bluebird"]]],["^1A","goog/string/string.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","~$goog.dom.safe","^3N","^3>","^39"]]],["^1A","goog/reflect/reflect.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12"]]],["^1A","goog/labs/useragent/util.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^39"]]],["^1A","goog/string/stringbuffer.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12"]]],["^1A","promesa/protocols.cljc"],["72c39dc84c953e2d6cc8bf760e61be7302042487","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^G"]]],["^1A","goog/iter/iter.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^35","^36","^3K","~$goog.math"]]],["^1A","goog/html/uncheckedconversions.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^36","^3L","^3G","^3M","^3S","^3I","^3;","^3>","^39","^3<"]]],["^1A","goog/dom/htmlelement.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12"]]],["^1A","cljs/core.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","~$goog.math.Long","~$goog.math.Integer","^3W","^38","^35","~$goog.Uri","~$goog.string.StringBuffer"]]],["^1A","goog/html/safescript.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^3>","^3?","^3H","^36"]]],["^1A","goog/html/safestylesheet.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^3>","^3M","^3?","^35","^38","^36","^39"]]],["^1A","goog/math/integer.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^3E"]]],["^1A","goog/uri/utils.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^36","^3W"]]],["^1A","goog/string/const.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^30",["^ ","^31",null,"^32",["^J",[]],"^33",["^12","^36","^3?"]]]]],"~:clj-info",["^ ","jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/core.cljc",1633630489000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/core.clj",1633630487000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer.cljc",1633630489000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/env.cljc",1633630489000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/inspect.clj",1633630480000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader.clj",1633630480000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/source_map/base64.clj",1633630489000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/default_data_readers.clj",1633630480000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/compiler.cljc",1633630489000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/edn.clj",1633630487000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer/passes/and_or.cljc",1633630489000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/util.cljc",1633630489000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/string.clj",1633630487000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/externs.clj",1633630489000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/set.clj",1633630487000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer/impl.cljc",1633630489000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/instant.clj",1633630487000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/tagged_literals.cljc",1633630489000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/java/io.clj",1633630487000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/reader_types.clj",1633630480000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/js_deps.cljc",1633630489000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/data.json/2.4.0/data.json-2.4.0.jar!/clojure/data/json.clj",1633630477000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/pprint.clj",1633630487000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/errors.clj",1633630480000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer/passes.cljc",1633630489000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/instant.clj",1633630489000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/source_map/base64_vlq.clj",1633630489000,"jar:file:/C:/Users/Mega/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/source_map.clj",1633630489000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","promesa/core.cljc","^7",25,"^8",5,"^9",25,"^:",17],"^;",["^ ","^<","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G"],"^H",null,"^I",["^J",["^K","^L","^M","^N","^O","^P"]],"^Q","^R","^S",["^ "],"^V",null,"^W",["^ ","^X","^X","^Y","^X","^Z","^Z","^[","^Z","^10","^10","^11","^10","^G","^G","^12","^12"],"^13",["^J",["^14"]],"~:shadow/js-access-global",["^J",["Error"]],"^15",null,"~:defs",["^ ","~$timeout",["^ ","~:protocol-inline",null,"^5",["^ ","^6","promesa/core.cljc","^7",253,"^8",10,"^9",253,"^:",17,"~:arglists",["^18",["~$quote",["^18",[["~$p","~$t"],["~$p","~$t","~$v"]]]]],"~:doc","Returns a cancellable promise that will be fulfilled\n     with this promise's fulfillment value or rejection reason.\n     However, if this promise is not fulfilled or rejected\n     within `ms` milliseconds, the returned promise is cancelled\n     with a TimeoutError","~:top-fn",["^ ","~:variadic?",false,"~:fixed-arity",3,"~:max-fixed-arity",3,"~:method-params",[["~$p","~$t"],["~$p","~$t","~$v"]],"^4Z",["^18",[["~$p","~$t"],["~$p","~$t","~$v"]]],"~:arglists-meta",["^18",[null,null]]]],"^Q","^2S","^6","promesa/core.cljc","^:",17,"^51",["^ ","^52",false,"^53",3,"^54",3,"^55",[["~$p","~$t"],["~$p","~$t","~$v"]],"^4Z",["^18",[["~$p","~$t"],["~$p","~$t","~$v"]]],"^56",["^18",[null,null]]],"^55",[["~$p","~$t"],["~$p","~$t","~$v"]],"~:protocol-impl",null,"^53",3,"^56",["^18",[null,null]],"^8",4,"^52",false,"~:methods",[["^ ","^53",2,"^52",false,"~:tag","~$any"],["^ ","^53",3,"^52",false,"^59","^5:"]],"^7",253,"^9",253,"^54",3,"~:fn-var",true,"^4Z",["^18",[["~$p","~$t"],["~$p","~$t","~$v"]]],"^50","Returns a cancellable promise that will be fulfilled\n     with this promise's fulfillment value or rejection reason.\n     However, if this promise is not fulfilled or rejected\n     within `ms` milliseconds, the returned promise is cancelled\n     with a TimeoutError"],"~$Promise",["^ ","^5",["^ ","^6","promesa/core.cljc","^7",43,"^8",23,"^9",43,"^:",30,"~:const",true],"^Q","^1S","^6","promesa/core.cljc","^:",30,"^8",10,"^5=",true,"^7",43,"^9",43,"^59","~$js"],"~$branch",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",149,"^8",7,"^9",149,"^:",13,"^4Z",["^18",["^4[",["^18",[["~$p","~$success","~$failure"]]]]]],"^Q","^22","^6","promesa/core.cljc","^:",13,"^55",["^18",[["~$p","^5@","^5A"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",149,"~:ret-tag","^5:","^9",149,"^54",3,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$p","^5@","^5A"]]]]]],"~$attempt",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",276,"^8",7,"^9",276,"^:",14,"^4Z",["^18",["^4[",["^18",[["~$callback"]]]]],"^50","A helper for start promise chain without worry about\n  synchronous or asynchronous exceptions. Returns a promise\n  resolved with the return value of the callback."],"^Q","^24","^6","promesa/core.cljc","^:",14,"^55",["^18",[["^5D"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",276,"^5B","^5:","^9",276,"^54",1,"^5;",true,"^4Z",["^18",["^4[",["^18",[["^5D"]]]]],"^50","A helper for start promise chain without worry about\n  synchronous or asynchronous exceptions. Returns a promise\n  resolved with the return value of the callback."],"^K",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",107,"^8",7,"^9",107,"^:",10,"^4Z",["^18",["^4[",["^18",[["~$f","~$p"]]]]],"^50","Apply a function to the promise value and\n  return a new promise with the result."],"^Q","^2;","^6","promesa/core.cljc","^:",10,"^55",["^18",[["~$f","~$p"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",107,"^5B","^5:","^9",107,"^54",2,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$f","~$p"]]]]],"^50","Apply a function to the promise value and\n  return a new promise with the result."],"^L",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",262,"^8",7,"^9",262,"^:",12,"^4Z",["^18",["^4[",["^18",[["~$t"],["~$t","~$v"]]]]],"^50","Given a timeout in miliseconds and optional\n  value, returns a promise that will fulfilled\n  with provided value (or nil) after the\n  time is reached.","^51",["^ ","^52",false,"^53",2,"^54",2,"^55",[["~$t"],["~$t","~$v"]],"^4Z",["^18",[["~$t"],["~$t","~$v"]]],"^56",["^18",[null,null]]]],"^Q","^2P","^6","promesa/core.cljc","^:",12,"^51",["^ ","^52",false,"^53",2,"^54",2,"^55",[["~$t"],["~$t","~$v"]],"^4Z",["^18",[["~$t"],["~$t","~$v"]]],"^56",["^18",[null,null]]],"^55",[["~$t"],["~$t","~$v"]],"^57",null,"^53",2,"^56",["^18",[null,null]],"^8",1,"^52",false,"^58",[["^ ","^53",1,"^52",false,"^59","^5:"],["^ ","^53",2,"^52",false,"^59","^5:"]],"^7",262,"^9",262,"^54",2,"^5;",true,"^4Z",["^18",[["~$t"],["~$t","~$v"]]],"^50","Given a timeout in miliseconds and optional\n  value, returns a promise that will fulfilled\n  with provided value (or nil) after the\n  time is reached."],"~$resolved?",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",81,"^8",7,"^9",81,"^:",16,"^4Z",["^18",["^4[",["^18",[["~$p"]]]]],"^50","Returns true if promise `p` is already fulfilled."],"^Q","^2:","^6","promesa/core.cljc","^:",16,"^55",["^18",[["~$p"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",81,"^5B","^5:","^9",81,"^54",1,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$p"]]]]],"^50","Returns true if promise `p` is already fulfilled."],"^M",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",113,"^8",7,"^9",113,"^:",13,"^4Z",["^18",["^4[",["^18",[["~$f","~$p"]]]]],"^50","Same as `map` but removes one level of\n  promise neesting. Useful when the map function\n  returns a promise instead of value.\n\n  In JS environment this function is analogous\n  to `map` because the promise abstraction overloads\n  the `map` operator."],"^Q","^1Q","^6","promesa/core.cljc","^:",13,"^55",["^18",[["~$f","~$p"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",113,"^5B","^5:","^9",113,"^54",2,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$f","~$p"]]]]],"^50","Same as `map` but removes one level of\n  promise neesting. Useful when the map function\n  returns a promise instead of value.\n\n  In JS environment this function is analogous\n  to `map` because the promise abstraction overloads\n  the `map` operator."],"~$cancelled?",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",231,"^8",7,"^9",231,"^:",17,"^4Z",["^18",["^4[",["^18",[["~$v"]]]]],"^50","Return true if `v` is a cancelled promise."],"^Q","^2=","^6","promesa/core.cljc","^:",17,"^55",["^18",[["~$v"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",231,"^5B","^5:","^9",231,"^54",1,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$v"]]]]],"^50","Return true if `v` is a cancelled promise."],"^N",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",294,"^8",7,"^9",294,"^:",12,"^4Z",["^18",["^4[",["^18",[["~$&","~$args"]]]]],"^51",["^ ","^52",true,"^53",0,"^54",0,"^55",[["^18",["^5G"]]],"^4Z",["^18",[["~$&","^5G"]]],"^56",["^18",[null]]]],"^Q","^2R","^6","promesa/core.cljc","^:",12,"^51",["^ ","^52",true,"^53",0,"^54",0,"^55",[["^18",["^5G"]]],"^4Z",["^18",[["~$&","^5G"]]],"^56",["^18",[null]]],"^55",[["^18",["^5G"]]],"^57",null,"^53",0,"^56",["^18",[null]],"^8",1,"^52",true,"^58",[["^ ","^53",0,"^52",true,"^59","~$ignore"]],"^7",294,"^5B","^5:","^9",294,"^54",0,"^5;",true,"^4Z",["^18",[["~$&","^5G"]]]],"~$bind",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",124,"^8",7,"^9",124,"^:",11,"^4Z",["^18",["^4[",["^18",[["~$p","~$f"]]]]],"^50","A chain helper for promises."],"^Q","^27","^6","promesa/core.cljc","^:",11,"^55",["^18",[["~$p","~$f"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",124,"^5B","^5:","^9",124,"^54",2,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$p","~$f"]]]]],"^50","A chain helper for promises."],"^5:",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",213,"^8",7,"^9",213,"^:",10,"^4Z",["^18",["^4[",["^18",[["~$promises"]]]]],"^50","Given an array of promises, return a promise\n  that is fulfilled when first one item in the\n  array is fulfilled."],"^Q","^2M","^6","promesa/core.cljc","^:",10,"^55",["^18",[["^5J"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",213,"^5B","^5>","^9",213,"^54",1,"^5;",true,"^4Z",["^18",["^4[",["^18",[["^5J"]]]]],"^50","Given an array of promises, return a promise\n  that is fulfilled when first one item in the\n  array is fulfilled."],"~$finally",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",177,"^8",7,"^9",177,"^:",14,"^4Z",["^18",["^4[",["^18",[["~$p","^5D"]]]]],"^50","Attach handler to promise that will be\n  executed independently if promise is\n  resolved or rejected."],"^Q","^2G","^6","promesa/core.cljc","^:",14,"^55",["^18",[["~$p","^5D"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",177,"^5B","^5:","^9",177,"^54",2,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$p","^5D"]]]]],"^50","Attach handler to promise that will be\n  executed independently if promise is\n  resolved or rejected."],"~$schedule",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",47,"^8",7,"^9",47,"^:",15,"^4Z",["^18",["^4[",["^18",[["~$ms","~$func"]]]]],"^50","Schedule a callable to be executed after the `ms` delay\n  is reached.\n\n  In JVM it uses a scheduled executor service and in JS\n  it uses the `setTimeout` function."],"^Q","^2H","^6","promesa/core.cljc","^:",15,"^55",["^18",[["^5M","^5N"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",47,"^5B","^5:","^9",47,"^54",2,"^5;",true,"^4Z",["^18",["^4[",["^18",[["^5M","^5N"]]]]],"^50","Schedule a callable to be executed after the `ms` delay\n  is reached.\n\n  In JVM it uses a scheduled executor service and in JS\n  it uses the `setTimeout` function."],"~$promisify",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",238,"^8",7,"^9",238,"^:",16,"^4Z",["^18",["^4[",["^18",[["~$callable"]]]]],"^50","Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation)."],"^Q","^1P","^6","promesa/core.cljc","^:",16,"^55",["^18",[["^5P"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",238,"^5B","~$function","^9",238,"^54",1,"^5;",true,"^4Z",["^18",["^4[",["^18",[["^5P"]]]]],"^50","Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation)."],"~$rejected",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",63,"^8",7,"^9",63,"^:",15,"^4Z",["^18",["^4[",["^18",[["~$v"]]]]],"^50","Return a rejected promise with provided reason."],"^Q","^23","^6","promesa/core.cljc","^:",15,"^55",["^18",[["~$v"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",63,"^5B","^5>","^9",63,"^54",1,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$v"]]]]],"^50","Return a rejected promise with provided reason."],"^P",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",68,"^8",7,"^9",68,"^:",14,"^4Z",["^18",["^4[",["^18",[["~$v"]]]]],"^50","The promise constructor."],"^Q","^1M","^6","promesa/core.cljc","^:",14,"^55",["^18",[["~$v"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",68,"^5B","^5:","^9",68,"^54",1,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$v"]]]]],"^50","The promise constructor."],"~$cancel!",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",225,"^8",7,"^9",225,"^:",14,"^4Z",["^18",["^4[",["^18",[["~$p"]]]]],"^50","Cancel the promise."],"^Q","^2F","^6","promesa/core.cljc","^:",14,"^55",["^18",[["~$p"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",225,"^9",225,"^54",1,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$p"]]]]],"^50","Cancel the promise."],"~$done?",["^ ","^5",["^ ","^6","promesa/core.cljc","^7",101,"^8",6,"^9",101,"^:",11],"^Q","^2I","^6","promesa/core.cljc","^:",11,"^8",1,"^7",101,"^9",101,"^59","^5Q","^50","Returns true if promise `p` is already done."],"~$err",["^ ","^Q","^2W","^6","promesa/core.cljc","^7",173,"^8",1,"^9",173,"^:",9,"^5",["^ ","^6","promesa/core.cljc","^7",173,"^8",6,"^9",173,"^:",9],"^50","A short alias for `error` function."],"~$all",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",187,"^8",7,"^9",187,"^:",10,"^4Z",["^18",["^4[",["^18",[["^5J"]]]]],"^50","Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \", \" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected."],"^Q","^2<","^6","promesa/core.cljc","^:",10,"^55",["^18",[["^5J"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",187,"^5B","^5:","^9",187,"^54",1,"^5;",true,"^4Z",["^18",["^4[",["^18",[["^5J"]]]]],"^50","Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \", \" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected."],"~$promise?",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",73,"^8",7,"^9",73,"^:",15,"^4Z",["^18",["^4[",["^18",[["~$v"]]]]],"^50","Return true if `v` is a promise instance."],"^Q","^2V","^6","promesa/core.cljc","^:",15,"^55",["^18",[["~$v"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",73,"^5B","~$boolean","^9",73,"^54",1,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$v"]]]]],"^50","Return true if `v` is a promise instance."],"~$resolved",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",58,"^8",7,"^9",58,"^:",15,"^4Z",["^18",["^4[",["^18",[["~$v"]]]]],"^50","Return a resolved promise with provided value."],"^Q","^2>","^6","promesa/core.cljc","^:",15,"^55",["^18",[["~$v"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",58,"^5B","^5>","^9",58,"^54",1,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$v"]]]]],"^50","Return a resolved promise with provided value."],"~$catch",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",155,"^8",7,"^9",155,"^:",12,"^4Z",["^18",["^4[",["^18",[["~$p","~$f"],["~$p","~$pred-or-type","~$f"]]]]],"^50","Catch all promise chain helper.","^51",["^ ","^52",false,"^53",3,"^54",3,"^55",[["~$p","~$f"],["~$p","^5[","~$f"]],"^4Z",["^18",[["~$p","~$f"],["~$p","^5[","~$f"]]],"^56",["^18",[null,null]]]],"^Q","^1T","^6","promesa/core.cljc","^:",12,"^51",["^ ","^52",false,"^53",3,"^54",3,"^55",[["~$p","~$f"],["~$p","^5[","~$f"]],"^4Z",["^18",[["~$p","~$f"],["~$p","^5[","~$f"]]],"^56",["^18",[null,null]]],"^55",[["~$p","~$f"],["~$p","^5[","~$f"]],"^57",null,"^53",3,"^56",["^18",[null,null]],"^8",1,"^52",false,"^58",[["^ ","^53",2,"^52",false,"^59","^5:"],["^ ","^53",3,"^52",false,"^59","^5:"]],"^7",155,"^9",155,"^54",3,"^5;",true,"^4Z",["^18",[["~$p","~$f"],["~$p","^5[","~$f"]]],"^50","Catch all promise chain helper."],"~$chain",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",144,"^8",7,"^9",144,"^:",12,"^4Z",["^18",["^4[",["^18",[["~$p","~$&","~$funcs"]]]]],"^50","Like then but accepts multiple parameters.","^51",["^ ","^52",true,"^53",1,"^54",1,"^55",[["^18",["~$p","^61"]]],"^4Z",["^18",[["~$p","~$&","^61"]]],"^56",["^18",[null]]]],"^Q","^2Q","^6","promesa/core.cljc","^:",12,"^51",["^ ","^52",true,"^53",1,"^54",1,"^55",[["^18",["~$p","^61"]]],"^4Z",["^18",[["~$p","~$&","^61"]]],"^56",["^18",[null]]],"^55",[["^18",["~$p","^61"]]],"^57",null,"^53",1,"^56",["^18",[null]],"^8",1,"^52",true,"^58",[["^ ","^53",1,"^52",true,"^59",["^J",[null,"^5:"]]]],"^7",144,"^5B","^5:","^9",144,"^54",1,"^5;",true,"^4Z",["^18",[["~$p","~$&","^61"]]],"^50","Like then but accepts multiple parameters."],"~$rejected?",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",86,"^8",7,"^9",86,"^:",16,"^4Z",["^18",["^4[",["^18",[["~$p"]]]]],"^50","Returns true if promise `p` is already rejected."],"^Q","^21","^6","promesa/core.cljc","^:",16,"^55",["^18",[["~$p"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",86,"^5B","^5:","^9",86,"^54",1,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$p"]]]]],"^50","Returns true if promise `p` is already rejected."],"~$then",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",129,"^8",7,"^9",129,"^:",11,"^4Z",["^18",["^4[",["^18",[["~$p","~$f"]]]]],"^50","Similar to `map` but with parameters inverted\n  for convenience and for familiarity with\n  javascript's promises `.then` operator.\n\n  Unlike Clojure's `map`, will resolve any promises\n  returned  by `f`."],"^Q","^2L","^6","promesa/core.cljc","^:",11,"^55",["^18",[["~$p","~$f"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",129,"^5B","^5:","^9",129,"^54",2,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$p","~$f"]]]]],"^50","Similar to `map` but with parameters inverted\n  for convenience and for familiarity with\n  javascript's promises `.then` operator.\n\n  Unlike Clojure's `map`, will resolve any promises\n  returned  by `f`."],"~$extract",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",96,"^8",7,"^9",96,"^:",14,"^4Z",["^18",["^4[",["^18",[["~$p"]]]]],"^50","Returns the current promise value."],"^Q","^1Y","^6","promesa/core.cljc","^:",14,"^55",["^18",[["~$p"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",96,"^5B","^5:","^9",96,"^54",1,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$p"]]]]],"^50","Returns the current promise value."],"~$error",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",168,"^8",7,"^9",168,"^:",12,"^4Z",["^18",["^4[",["^18",[["~$f","~$p"],["~$f","~$type","~$p"]]]]],"^50","Same as `catch` but with parameters inverted.","^51",["^ ","^52",false,"^53",3,"^54",3,"^55",[["~$f","~$p"],["~$f","^66","~$p"]],"^4Z",["^18",[["~$f","~$p"],["~$f","^66","~$p"]]],"^56",["^18",[null,null]]]],"^Q","^2C","^6","promesa/core.cljc","^:",12,"^51",["^ ","^52",false,"^53",3,"^54",3,"^55",[["~$f","~$p"],["~$f","^66","~$p"]],"^4Z",["^18",[["~$f","~$p"],["~$f","^66","~$p"]]],"^56",["^18",[null,null]]],"^55",[["~$f","~$p"],["~$f","^66","~$p"]],"^57",null,"^53",3,"^56",["^18",[null,null]],"^8",1,"^52",false,"^58",[["^ ","^53",2,"^52",false,"^59","^5:"],["^ ","^53",3,"^52",false,"^59","^5:"]],"^7",168,"^9",168,"^54",3,"^5;",true,"^4Z",["^18",[["~$f","~$p"],["~$f","^66","~$p"]]],"^50","Same as `catch` but with parameters inverted."],"~$pending?",["^ ","^4Y",null,"^5",["^ ","^6","promesa/core.cljc","^7",91,"^8",7,"^9",91,"^:",15,"^4Z",["^18",["^4[",["^18",[["~$p"]]]]],"^50","Returns true if promise `p` is stil pending."],"^Q","^2@","^6","promesa/core.cljc","^:",15,"^55",["^18",[["~$p"]]],"^57",null,"^56",["^18",[null,null]],"^8",1,"^52",false,"^7",91,"^5B","^5:","^9",91,"^54",1,"^5;",true,"^4Z",["^18",["^4[",["^18",[["~$p"]]]]],"^50","Returns true if promise `p` is stil pending."]],"^16",["^ ","^G","^G"],"~:cljs.analyzer/constants",["^ ","^13",["^J",["~:else"]],"~:order",["^69"]],"^1=",["^ ","^14",["^J",[]]],"^1>",["^ "],"^1?",["^12","^G","^X","^Z","^10"]],"^U","^R","~:ns-specs",["^ "],"~:ns-spec-vars",["^J",[]],"~:compiler-options",["^2[",[["^6=","~:static-fns"],true,["^6=","~:shadow-tweaks"],null,["^6=","~:source-map-inline"],null,["^6=","~:elide-asserts"],false,["^6=","~:optimize-constants"],null,["^6=","^1D"],null,["^6=","~:external-config"],null,["^6=","~:tooling-config"],null,["^6=","~:emit-constants"],null,["^6=","~:load-tests"],null,["^6=","~:form-size-threshold"],null,["^6=","~:data-readers"],null,["^6=","~:infer-externs"],"~:auto",["^6=","^1F"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^6=","~:fn-invoke-direct"],null,["^6=","~:source-map"],"/dev/null"]]]